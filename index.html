<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Card Rogue</title>
    <style>
        body {
            background: #111;
            color: white;
            text-align: center;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        .hidden {
            display: none !important;
        }

        /* ã‚«ãƒ¼ãƒ‰ã®åŸºæœ¬ãƒ‡ã‚¶ã‚¤ãƒ³ */
        .card {
            width: 120px;
            height: 155px;
            background: #000;
            border: 3px solid #fff;
            border-radius: 10px;
            margin: 5px;
            padding: 8px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            vertical-align: top;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            transition: transform 0.2s, background-color 0.2s;
            position: relative;
        }

        /* ãƒ¬ã‚¢åº¦åˆ¥ã®æŒ‡å®šè‰² */
        .rarity-3 { border-color: #007bff; box-shadow: 0 0 8px rgba(0, 123, 255, 0.6); }
        .rarity-4 { border-color: #ffd700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
        .rarity-5 { 
            border-color: #fff;
            border-image: linear-gradient(45deg, #e6e6fa, #add8e6, #ffffff, #e6e6fa) 1;
            box-shadow: 0 0 15px rgba(230, 230, 250, 0.8);
            animation: shine 3s linear infinite;
        }

        @keyframes shine {
            0% { filter: hue-rotate(0deg) brightness(1); }
            50% { filter: hue-rotate(10deg) brightness(1.2); }
            100% { filter: hue-rotate(0deg) brightness(1); }
        }

        /* --- ç‰¹æ®Šæ¼”å‡ºï¼šãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®æŒ¯å‹•ã¨èµ¤ç‚¹æ»… --- */
        .dmg-flash {
            background-color: #ff0000 !important;
            animation: shake 0.4s ease-in-out;
            z-index: 10;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) scale(1.1); }
            10% { transform: translate(-2px, -2px) scale(1.1); }
            20% { transform: translate(-4px, 0px) scale(1.1); }
            30% { transform: translate(4px, 2px) scale(1.1); }
            40% { transform: translate(1px, -1px) scale(1.1); }
            50% { transform: translate(-1px, 2px) scale(1.1); }
            60% { transform: translate(-4px, 1px) scale(1.1); }
            70% { transform: translate(4px, 1px) scale(1.1); }
            80% { transform: translate(-1px, -1px) scale(1.1); }
            90% { transform: translate(1px, 2px) scale(1.1); }
            100% { transform: translate(0px, 0px) scale(1.0); }
        }

        /* ãƒ‡ãƒƒã‚­ã‚¨ãƒªã‚¢ */
        #deck {
            border: 2px solid #444; background: #1a1a1a; min-height: 170px;
            margin: 10px auto; width: 90%; display: flex; justify-content: center;
            align-items: center; border-radius: 15px; flex-wrap: wrap;
        }

        /* å£²å´ã‚¾ãƒ¼ãƒ³ */
        #sellZone {
            border: 2px dashed #ff4444; height: 80px; margin: 15px auto; width: 80%;
            display: flex; justify-content: center; align-items: center;
            border-radius: 10px; background: rgba(255, 68, 68, 0.1);
        }
        #sellZone::after { content: "ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å£²å´"; color: #ffaaaa; }

        /* ãã®ä»–ãƒ‘ãƒ¼ãƒ„ */
        #log {
            height: 120px; background: rgba(0,0,0,0.8); border-bottom: 2px solid #444;
            overflow-y: auto; font-size: 0.85em; padding: 8px; text-align: left;
        }
        #enemyArea { height: 35vh; display: flex; justify-content: center; align-items: center; }
        #allyArea { position: fixed; bottom: 20px; width: 100%; display: flex; justify-content: center; }

        button { padding: 10px 20px; cursor: pointer; margin: 5px; background: #333; color: white; border: 1px solid #777; border-radius: 5px; }
        .btn-battle { background: #28a745; font-weight: bold; font-size: 1.1em; border: none; }

        #clearScreen, #gameOverScreen {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 9999;
        }
    </style>
</head>
<body>

<div id="fade"></div>
<h2 id="stageText">Stage 1</h2>

<div id="start">
    <h1>Card Rogue</h1>
    <button onclick="startGame()">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button>å›³é‘‘(æœªå®Ÿè£…)</button>
    <button onclick="alert('æ•µã‚’å€’ã—ã¦é€²ã‚€ã ã‘ã§ã™')">ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«</button>
</div>

<div id="shop" class="hidden">
    <h3>Coin: <span id="coinText"></span></h3>
    <div id="shopCards"></div>
    <button onclick="reroll()">æ›´æ–°(1ã‚³ã‚¤ãƒ³)</button>
    <h3>ãƒ‡ãƒƒã‚­ (æœ€å¤§5æš / åŒã˜ã‚­ãƒ£ãƒ©ã§ãƒ©ãƒ³ã‚¯UP)</h3>
    <div id="deck"></div>
    <h3 style="color: #ff4444;">å£²å´ã‚¾ãƒ¼ãƒ³ (ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°)</h3>
    <div id="sellZone"></div>
    <button onclick="battle()" class="btn-battle">æˆ¦é—˜é–‹å§‹</button>
</div>

<div id="battle" class="hidden">
    <div id="log"></div>
    <div id="enemyArea"></div>
    <div id="allyArea" onclick="nextTurn()"></div>
</div>

<div id="clearScreen" class="hidden">
    <h1>GAME CLEAR</h1>
    <button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<div id="gameOverScreen" class="hidden" onclick="backToTitle()">
    <h1 class="text-danger">GAME OVER</h1>
    <p>ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</p>
    <button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<script>
// --- åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ã¨å¤‰æ•° ---
const baseChars=[
    {name:"ã‚¹ã‚¦",atk:300,hp:3000,rarity:3},
    {name:"ãƒ¬ã‚ªãƒŠ",atk:400,hp:4000,rarity:4},
    {name:"ã‚³ã‚¦",atk:500,hp:7000,rarity:5},
    {name:"ã‚­ãƒ§ã‚¦",atk:300,hp:1000,rarity:3},
    {name:"ã‚«ãƒ•",atk:400,hp:4000,rarity:4},
    {name:"ã‚¤ã‚°ãƒã‚¢",atk:300,hp:3000,rarity:3},
    {name:"ã‚¢ãƒ¬ã‚¯ã‚µãƒ³ãƒ€ãƒ¼",atk:999,hp:9999,rarity:5},
    {name:"ã‚¹ãƒ•ã‚§ãƒªã‚³ãƒ³",atk:400,hp:4000,rarity:4},
    {name:"èœœå¤œ",atk:400,hp:4000,rarity:4},
    {name:"ãƒ¡ãƒ“ã‚¦ã‚¹",atk:400,hp:4000,rarity:4},
    {name:"ãƒ­ãƒ¼ãƒãƒ³",atk:300,hp:3000,rarity:3},
    {name:"ã‚´ãƒ",atk:1,hp:3,rarity:3},
    {name:"ã‚³ã‚³ã­ã“",atk:999,hp:9999,rarity:5},
    {name:"ãœã‚‹ãœã‚‹ãƒ¤ãƒ‰ã‚«ãƒª",atk:436,hp:9999,rarity:4},
    {name:"æœ€å¼·ç„¡æ•µã‚ªãƒ¬ã‚ªãƒ”ãƒ¼ãƒãƒ³",atk:9999,hp:99999,rarity:5},
    {name:"ã­ã“ã«",atk:0,hp:1,rarity:3},
];

const enemyTypes = {
    slime: { name: "ã‚¹ãƒ©ã‚¤ãƒ ", hp: 2500, atk: 600, action: "slime_skill" },
    golem: { name: "ã‚´ãƒ¼ãƒ¬ãƒ ", hp: 3000, atk: 200, action: "golem_skill" },
    kurorekishi: { name: "é»’æ­´å²", hp: 6000, atk: 100, action: "kuro_skill" },
    nouki: { name: "ç´æœŸ", hp: 7000, atk: 600, action: "nouki_skill" }
};

let stage=1, coin=6, deck=[], shop=[];
let enemy, turnIndex=0;
let battlePhase = "idle"; 
let actorIndex = 0; 

const startDiv=document.getElementById("start");
const shopDiv=document.getElementById("shop");
const battleDiv=document.getElementById("battle");
const clearScreen=document.getElementById("clearScreen");
const gameOverScreen=document.getElementById("gameOverScreen");
const shopCards=document.getElementById("shopCards");
const deckDiv=document.getElementById("deck");
const sellZone=document.getElementById("sellZone");
const coinText=document.getElementById("coinText");
const stageText=document.getElementById("stageText");
const enemyArea=document.getElementById("enemyArea");
const allyArea=document.getElementById("allyArea");
const logDiv=document.getElementById("log");

function log(t){ 
    logDiv.innerHTML += t+"<br>"; 
    logDiv.scrollTop = logDiv.scrollHeight;
}
function cost(r){return r==3?2:r==4?3:4;}
function copyChar(c){return {...c,rank:1,currentHp:c.hp,status:[]};}
function getIcon(type){
    switch(type){
        case "æ¯’": return "â˜ ï¸"; case "éº»ç—º": return "âš¡";
        case "æ‹˜æŸ": return "â›“ï¸"; case "èˆˆå¥®": return "ğŸ’¥";
        default: return "â“";
    }
}
function hideAllScreens() { [startDiv, shopDiv, battleDiv, clearScreen, gameOverScreen].forEach(div => div.classList.add("hidden")); }

window.onload=()=>{ hideAllScreens(); startDiv.classList.remove("hidden"); };
function startGame(){ stage=1; coin=6; deck=[]; hideAllScreens(); shopDiv.classList.remove("hidden"); refreshShop(); }

function backToTitle(){
    stage = 1; coin = 6; enemy = null; turnIndex = 0; deck = []; shop = [];
    hideAllScreens(); startDiv.classList.remove("hidden");
    logDiv.innerHTML=""; coinText.innerText = coin; stageText.innerText = "Stage "+stage;
    drawDeck(); shopCards.innerHTML="";
}

function refreshShop(){
    stageText.innerText="Stage "+stage; coinText.innerText=coin; shop=[];
    let pool=rarityPool();
    for(let i=0;i<6;i++){
        let r=pool[Math.random()*pool.length|0];
        let list=baseChars.filter(c=>c.rarity==r);
        shop.push(copyChar(list[Math.random()*list.length|0]));
    }
    drawShop(); drawDeck();
}

function rarityPool(){ if(stage<=3) return [3]; if(stage<=6) return [3,4]; return [3,3,4,4,5]; }

function drawShop(){
    shopCards.innerHTML="";
    shop.forEach((c,i)=>{
        let d=document.createElement("div");
        d.className=`card rarity-${c.rarity}`;
        d.draggable=true;
        d.innerHTML=`${c.name}<br>âš”ï¸${c.atk}<br>â™¥${c.hp}<br>${cost(c.rarity)}c`;
        d.ondragstart=e=>e.dataTransfer.setData("shopIndex",i);
        shopCards.appendChild(d);
    });
}

function drawDeck(){
    deckDiv.innerHTML="";
    deck.forEach((c,i)=>{
        let d=document.createElement("div");
        d.className=`card rarity-${c.rarity}`;
        d.draggable=true;
        let statusHtml = (c.status || []).map(s=>`${s.level}${getIcon(s.type)}${s.turn}`).join(" ");
        let displayAtk = calcAtk(c);
        let displayMaxHp = c.hp + (c.rank - 1) * 800;
        let currentHpShow = c.currentHp !== undefined ? c.currentHp : displayMaxHp;
        d.innerHTML=`${c.name} â˜…${c.rank}<br>âš”ï¸${displayAtk}<br>â™¥${currentHpShow}/${displayMaxHp}<br><small>${statusHtml}</small>`;
        d.ondragstart=e=>e.dataTransfer.setData("deckIndex",i);
        deckDiv.appendChild(d);
    });
}

deckDiv.ondragover=e=>e.preventDefault();
deckDiv.ondrop=e=>{
    let i=e.dataTransfer.getData("shopIndex");
    if(i==="" || i===undefined) return;
    buy(Number(i));
};
sellZone.ondragover=e=>e.preventDefault();
sellZone.ondrop=e=>{
    let i=e.dataTransfer.getData("deckIndex");
    if(i==="" || i===undefined) return;
    let c=deck[i]; coin+=cost(c.rarity); deck.splice(i,1);
    coinText.innerText=coin; drawDeck();
};

function buy(i){
    let c = shop[i]; let p = cost(c.rarity);
    if(coin < p) return;
    let sameChar = deck.find(dc => dc.name === c.name);
    if(sameChar) {
        if(sameChar.rank < 5) {
            coin -= p; sameChar.rank += 1; shop.splice(i,1);
            log(`${c.name}ãŒåˆä½“ï¼ãƒ©ãƒ³ã‚¯${sameChar.rank}ã«ãªã£ãŸï¼`);
        } else { alert("æœ€å¤§ãƒ©ãƒ³ã‚¯ã§ã™ï¼"); return; }
    } else {
        if(deck.length >= 5) { alert("ãƒ‡ãƒƒã‚­ãŒã„ã£ã±ã„ã§ã™ï¼"); return; }
        coin -= p; deck.push(copyChar(c)); shop.splice(i,1);
    }
    coinText.innerText = coin; drawShop(); drawDeck();
}

function reroll(){ if(coin<=0) return; coin--; refreshShop(); }

function battle(){
    if(deck.length==0) { alert("ãƒ‡ãƒƒã‚­ã«ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ï¼"); return; }
    hideAllScreens(); battleDiv.classList.remove("hidden"); startBattle();
}

function startBattle(){
    logDiv.innerHTML = "";
    let et;
    if (stage <= 4) et = Math.random() < 0.5 ? enemyTypes.slime : enemyTypes.golem;
    else if (stage === 5) et = enemyTypes.kurorekishi;
    else if (stage <= 9) et = Math.random() < 0.5 ? enemyTypes.slime : enemyTypes.golem;
    else et = enemyTypes.nouki;

    enemy = { ...et, hp: et.hp, status: [] };
    deck.forEach(c => {
        let maxHp = c.hp + (c.rank - 1) * 800;
        c.currentHp = maxHp; c.status = []; 
    });
    battlePhase = "ally"; actorIndex = 0; 
    drawEnemy(); drawAllies();
    log(`ã€${enemy.name}ã€‘ãŒç¾ã‚ŒãŸï¼`);
}

function nextTurn(){
    if (battlePhase === "end") { finishBattle(); return; }
    if (battlePhase === "ally") processAllyAction();
    else if (battlePhase === "enemy") processEnemyAction();
}

function processAllyAction() {
    if (actorIndex >= deck.length) {
        deck.forEach(c => applyStatus(c));
        battlePhase = "enemy"; drawAllies(); nextTurn(); 
        return;
    }
    let actor = deck[actorIndex];
    if (actor.currentHp <= 0) { actorIndex++; processAllyAction(); return; }
    log(`--- ${actor.name} ã®è¡Œå‹• ---`);
    if (isStunned(actor)) {
        log(actor.name + " ã¯æ‹˜æŸã§å‹•ã‘ãªã„ï¼");
    } else {
        let atk = calcAtk(actor);
        dealDamage(actor, enemy, atk); // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ã‚’çµ±ä¸€
    }
    actorIndex++; checkBattleEnd();
}

function processEnemyAction() {
    log(`--- ${enemy.name} ã®è¡Œå‹• ---`);
    let aliveTargets = deck.filter(c => c.currentHp > 0);
    if (aliveTargets.length === 0) return;
    let atk = calcAtk(enemy);

    switch (enemy.action) {
        case "slime_skill":
            let t1 = aliveTargets[Math.floor(Math.random() * aliveTargets.length)];
            dealDamage(enemy, t1, atk);
            addStatus(t1, "æ¯’", 1, 2); addStatus(t1, "éº»ç—º", 1, 2);
            break;
        case "golem_skill":
            let tGolems = shuffleArray([...aliveTargets]).slice(0, 3);
            tGolems.forEach(t => dealDamage(enemy, t, atk));
            if (Math.random() < 0.5) { addStatus(enemy, "èˆˆå¥®", 1, 2); }
            break;
        case "kuro_skill":
            aliveTargets.forEach(t => dealDamage(enemy, t, atk));
            let tKuros = shuffleArray([...aliveTargets]).slice(0, 2);
            tKuros.forEach(t => addStatus(t, "æ¯’", 3, 2));
            break;
        case "nouki_skill":
            let tNoukis = shuffleArray([...aliveTargets]).slice(0, 2);
            tNoukis.forEach(t => dealDamage(enemy, t, atk));
            if (Math.random() < 0.5) {
                let tLock = aliveTargets[Math.floor(Math.random() * aliveTargets.length)];
                addStatus(tLock, "æ‹˜æŸ", 1, 2);
            }
            break;
    }
    applyStatus(enemy); drawAllies(); drawEnemy();
    battlePhase = "ally"; actorIndex = 0; checkBattleEnd();
}

// --- ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ï¼ˆæŒ¯å‹•æ¼”å‡ºè¿½åŠ ç‰ˆï¼‰ ---
function dealDamage(attacker, target, dmg) {
    target.currentHp = Math.max(0, target.currentHp - dmg);
    log(`${attacker.name}ã®æ”»æ’ƒï¼ ${target.name}ã« ${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`);

    // DOMè¦ç´ ã®ç‰¹å®š
    let targetEl;
    if (target === enemy) {
        targetEl = enemyArea.querySelector('.card');
    } else {
        const allyCards = allyArea.querySelectorAll('.card');
        const aliveDeck = deck.filter(c => c.currentHp > 0 || c === target); // ç”Ÿå­˜é †ã«ä¸¦ã‚“ã§ã„ã‚‹DOMã‹ã‚‰æ¢ã™
        const targetIndexInDom = aliveDeck.indexOf(target);
        targetEl = allyCards[targetIndexInDom];
    }

    // æŒ¯å‹•ã¨èµ¤ç‚¹æ»…ã®ã‚¯ãƒ©ã‚¹ä»˜ä¸
    if (targetEl) {
        targetEl.classList.add('dmg-flash');
        setTimeout(() => targetEl.classList.remove('dmg-flash'), 400);
    }

    if (target.currentHp <= 0) {
        log(`<b style='color:red;'>${target.name} ãŒæˆ¦é—˜ä¸èƒ½ã«ãªã£ãŸï¼</b>`);
        if (target === enemy) drawEnemy(); else drawAllies();
    } else {
        if (target === enemy) drawEnemy(); else drawAllies();
    }
}

function addStatus(unit, type, level, turn) {
    if (!unit.status) unit.status = [];
    unit.status.push({ type, level, turn });
    log(`${unit.name} ã« ${type} ä»˜ä¸ï¼`);
    drawEnemy(); drawAllies();
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function checkBattleEnd() {
    if (enemy.hp <= 0 || enemy.currentHp <= 0) {
        log("<b style='color:yellow;'>å‹åˆ©ï¼ ç”»é¢ã‚¿ãƒƒãƒ—ã§æ¬¡ã¸</b>");
        battlePhase = "end";
    } else if (deck.every(c => c.currentHp <= 0)) {
        log("<b style='color:red;'>æ•—åŒ—... ç”»é¢ã‚¿ãƒƒãƒ—ã§çµ‚äº†</b>");
        battlePhase = "end";
    }
}

function finishBattle() {
    if (enemy.hp <= 0 || enemy.currentHp <= 0) {
        coin += 5; stage++; deck.forEach(c => { c.status = []; });
        if (stage > 10) { hideAllScreens(); clearScreen.classList.remove("hidden"); }
        else { hideAllScreens(); shopDiv.classList.remove("hidden"); refreshShop(); }
    } else {
        hideAllScreens(); gameOverScreen.classList.remove("hidden");
    }
}

function calcAtk(unit){
    let baseAtk = unit.atk;
    if(unit.rank) baseAtk += (unit.rank - 1) * 80;
    let multiplier = 1.0; 
    if(unit.status) unit.status.forEach(s=>{
        if(s.type === "éº»ç—º") multiplier -= 0.3;
        if(s.type === "èˆˆå¥®") multiplier += 0.5;
    });
    multiplier = Math.max(0.1, multiplier);
    return Math.floor(baseAtk * multiplier);
}

function drawEnemy(){
    if(!enemy) return;
    let statusHtml = enemy.status.map(s=>`<span style="background:rgba(0,0,0,0.3);padding:1px;border-radius:3px;">${s.level}${getIcon(s.type)}${s.turn}</span>`).join(" ");
    enemyArea.innerHTML = `<div class="card rarity-4">${enemy.name}<br>âš”ï¸${calcAtk(enemy)}<br>â™¥${enemy.currentHp !== undefined ? enemy.currentHp : enemy.hp}<br><div>${statusHtml}</div></div>`;
}

function drawAllies(){
    allyArea.innerHTML="";
    deck.forEach(c=>{
        if(c.currentHp<=0) return;
        let statusHtml = c.status.map(s=>`<span style="background:rgba(0,0,0,0.3);padding:1px;border-radius:3px;">${s.level}${getIcon(s.type)}${s.turn}</span>`).join(" ");
        allyArea.innerHTML += `<div class="card rarity-${c.rarity}">${c.name} â˜…${c.rank}<br>âš”ï¸${calcAtk(c)}<br>â™¥${c.currentHp}<br><div>${statusHtml}</div></div>`;
    });
}

function isStunned(c){ return c.status && c.status.some(s=>s.type==="æ‹˜æŸ"); }

function applyStatus(unit){
    if(!unit || !unit.status) return;
    let removeIndices=[];
    unit.status.forEach((s,i)=>{
        if(s.type==="æ¯’"){
            unit.currentHp = Math.max(0, unit.currentHp - s.level*100);
            log(unit.name+" ã¯æ¯’ã§ "+(s.level*100)+" ãƒ€ãƒ¡ãƒ¼ã‚¸");
            // æ¯’ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã‚‚ä¸€ç¬å…‰ã‚‰ã›ã‚‹æ¼”å‡ºã‚’å…¥ã‚Œã‚‹ã¨åˆ†ã‹ã‚Šã‚„ã™ã„
            let targetEl = (unit === enemy) ? enemyArea.querySelector('.card') : Array.from(allyArea.querySelectorAll('.card'))[deck.filter(c => c.currentHp >= 0 || c === unit).indexOf(unit)];
            if(targetEl) {
                targetEl.style.backgroundColor = "#550055"; // æ¯’ã¯ç´«ã£ã½ã
                setTimeout(() => targetEl.style.backgroundColor = "#000", 200);
            }
        }
        s.turn--;
        if(s.turn<=0) removeIndices.push(i);
    });
    removeIndices.reverse().forEach(i=>unit.status.splice(i,1));
}
</script>
</body>
</html>
