<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Card Rogue - Element Edition</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="fade"></div>
<h2 id="stageText">Stage 1</h2>

<div id="start">
    <h1>Card Rogue</h1>
    <button onclick="startGame()">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button>å›³é‘‘(æœªå®Ÿè£…)</button>
    <button onclick="alert('å±æ€§ã®å¼±ç‚¹ã‚’çªã„ã¦å‹åˆ©ã‚’ç›®æŒ‡ãã†ï¼')">ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«</button>
</div>

<div id="shop" class="hidden">
    <div style="display: flex; justify-content: space-around; align-items: center; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px; margin: 10px;">
        <div>Coin: <span id="coinText"></span></div>
        <div id="nextEnemyInfo" style="font-weight: bold; color: #ffcc00;">Next: ???</div>
    </div>
    
    <div id="shopCards"></div>
    <button onclick="reroll()">æ›´æ–°(1ã‚³ã‚¤ãƒ³)</button>
    <h3>ãƒ‡ãƒƒã‚­ (æœ€å¤§5æš / åŒã˜ã‚­ãƒ£ãƒ©ã§ãƒ©ãƒ³ã‚¯UP)</h3>
    <div id="deck"></div>
    <h3 style="color: #ff4444;">å£²å´ã‚¾ãƒ¼ãƒ³ (ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°)</h3>
    <div id="sellZone"></div>
    <button onclick="battle()" class="btn-battle">æˆ¦é—˜é–‹å§‹</button>
</div>

<div id="battle" class="hidden">
    <div id="log"></div>
    <div id="enemyArea"></div>
    <div id="allyArea" onclick="nextTurn()"></div>
</div>

<div id="clearScreen" class="hidden">
    <h1>GAME CLEAR</h1>
    <button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<div id="gameOverScreen" class="hidden" onclick="backToTitle()">
    <h1 class="text-danger">GAME OVER</h1>
    <p>ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</p>
    <button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<script>
// --- åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ ---
const baseChars=[
    {name:"ã‚¹ã‚¦",atk:300,hp:3000,rarity:3,elem:"å…‰", skill:{interval:3, action:(a,ts)=>ts.forEach(t=>addStatus(t,"éº»ç—º",2,2))}},
    {name:"ãƒ¬ã‚ªãƒŠ",atk:400,hp:5000,rarity:4,elem:"è‰"},
    {name:"ã‚³ã‚¦",atk:600,hp:7000,rarity:5,elem:"ç«"},
    {name:"ã‚­ãƒ§ã‚¦",atk:200,hp:2000,rarity:3,elem:"é—‡"},
    {name:"ã‚«ãƒ•",atk:500,hp:4000,rarity:4,elem:"æ°´"},
    {name:"ã‚¤ã‚°ãƒã‚¢",atk:200,hp:2000,rarity:3,elem:"å…‰"},
    {name:"ã‚¢ãƒ¬ã‚¯ã‚µãƒ³ãƒ€ãƒ¼",atk:999,hp:9999,rarity:5,elem:"ç«"},
    {name:"ã‚¹ãƒ•ã‚§ãƒªã‚³ãƒ³",atk:400,hp:4000,rarity:4,elem:"ç«"},
    {name:"èœœå¤œ",atk:400,hp:4000,rarity:4,elem:"è‰"},
    {name:"ãƒ¡ãƒ“ã‚¦ã‚¹",atk:400,hp:4000,rarity:4,elem:"ç«"},
    {name:"ãƒ­ãƒ¼ãƒãƒ³",atk:300,hp:3000,rarity:3,elem:"æ°´"},
    {name:"ã‚´ãƒ",atk:1,hp:3,rarity:3,elem:"é—‡"},
    {name:"ã‚³ã‚³ã­ã“",atk:999,hp:9999,rarity:5,elem:"é—‡"},
    {name:"ãœã‚‹ãœã‚‹ãƒ¤ãƒ‰ã‚«ãƒª",atk:436,hp:9999,rarity:4,elem:"æ°´"},
    {name:"æœ€å¼·ç„¡æ•µã‚ªãƒ¬ã‚ªãƒ”ãƒ¼ãƒãƒ³",atk:9999,hp:99999,rarity:5,elem:"è‰"},
    {name:"ã­ã“ã«",atk:0,hp:1,rarity:3,elem:"å…‰"},
];

const enemyTypes = {
    slime: { name: "ã‚¹ãƒ©ã‚¤ãƒ ", hp: 2500, atk: 300, elem: "æ°´", action: "slime_skill" },
    golem: { name: "ã‚´ãƒ¼ãƒ¬ãƒ ", hp: 3000, atk: 100, elem: "è‰", action: "golem_skill" },
    kurorekishi: { name: "é»’æ­´å²", hp: 10000, atk: 100, elem: "é—‡", action: "kuro_skill" },
    nouki: { name: "ç´æœŸ", hp: 15000, atk: 600, elem: "é—‡", action: "nouki_skill" }
};

let stage=1, coin=6, deck=[], shop=[];
let enemies = [], battlePhase = "idle", actorIndex = 0; 
let nextEnemies = []; // å…ˆèª­ã¿ç”¨ã®é…åˆ—

const startDiv=document.getElementById("start"), shopDiv=document.getElementById("shop"), battleDiv=document.getElementById("battle");
const clearScreen=document.getElementById("clearScreen"), gameOverScreen=document.getElementById("gameOverScreen");
const shopCards=document.getElementById("shopCards"), deckDiv=document.getElementById("deck"), sellZone=document.getElementById("sellZone");
const coinText=document.getElementById("coinText"), stageText=document.getElementById("stageText"), nextEnemyInfo=document.getElementById("nextEnemyInfo");
const enemyArea=document.getElementById("enemyArea"), allyArea=document.getElementById("allyArea"), logDiv=document.getElementById("log");

// --- ã‚·ã‚¹ãƒ†ãƒ é–¢æ•° ---
function log(t){ logDiv.innerHTML += t+"<br>"; logDiv.scrollTop = logDiv.scrollHeight; }
function cost(r){return r==3?2:r==4?3:4;}
function copyChar(c){return {...c,rank:1,currentHp:c.hp,status:[],skillCount:0};}
function getIcon(type){
    switch(type){
        case "æ¯’": return "â˜ ï¸"; case "éº»ç—º": return "âš¡";
        case "æ‹˜æŸ": return "â›“ï¸"; case "èˆˆå¥®": return "ğŸ’¥";
        default: return "â“";
    }
}
function hideAllScreens() { [startDiv, shopDiv, battleDiv, clearScreen, gameOverScreen].forEach(div => div.classList.add("hidden")); }

// --- å±æ€§ç›¸æ€§è¨ˆç®— ---
function getAffinity(aElem, tElem) {
    if (aElem === "ç«" && tElem === "è‰") return 1.5;
    if (aElem === "è‰" && tElem === "æ°´") return 1.5;
    if (aElem === "æ°´" && tElem === "ç«") return 1.5;
    if (aElem === "è‰" && tElem === "ç«") return 0.5;
    if (aElem === "æ°´" && tElem === "è‰") return 0.5;
    if (aElem === "ç«" && tElem === "æ°´") return 0.5;
    if ((aElem === "å…‰" && tElem === "é—‡") || (aElem === "é—‡" && tElem === "å…‰")) return 1.5;
    return 1.0;
}

// --- ã‚«ãƒ¼ãƒ‰HTMLç”Ÿæˆ ---
function createCardHtml(c, isEnemy = false) {
    const stars = "â˜…".repeat(c.rarity);
    const maxHp = isEnemy ? c.hp : (c.hp + (c.rank - 1) * 800);
    const currentHp = c.currentHp !== undefined ? c.currentHp : maxHp;
    const atk = calcAtk(c);
    const skillInfo = c.skill ? `<div class="skill-tag">${c.skillCount || 0}/${c.skill.interval}</div>` : "";
    const statusIcons = (c.status || []).map(s => `<span title="${s.type}">${getIcon(s.type)}${s.turn}</span>`).join("");

    return `
        ${skillInfo}
        <div class="elem-circle elem-${c.elem}">${isEnemy ? "" : c.rank}</div>
        <div class="rarity-stars">${stars}</div>
        <div class="card-status-icons">${statusIcons}</div>
        <div class="card-img-space"></div>
        <div class="card-name">${c.name}</div>
        <div class="card-atk">âš”ï¸${atk}</div>
        <div class="card-hp">â™¥${currentHp}</div>
    `;
}

window.onload=()=>{ hideAllScreens(); startDiv.classList.remove("hidden"); };
function startGame(){ stage=1; coin=6; deck=[]; hideAllScreens(); shopDiv.classList.remove("hidden"); refreshShop(); }

function backToTitle(){
    stage = 1; coin = 6; enemies = []; deck = []; shop = [];
    hideAllScreens(); startDiv.classList.remove("hidden");
    logDiv.innerHTML=""; coinText.innerText = coin; stageText.innerText = "Stage "+stage;
    drawDeck(); shopCards.innerHTML="";
}

// æ¬¡ã®æ•µã‚’ç”Ÿæˆã™ã‚‹å…±é€šãƒ­ã‚¸ãƒƒã‚¯
function generateNextEnemies() {
    let pool = [];
    let count = 1;
    if (stage <= 4) { count = 2; pool = [enemyTypes.slime, enemyTypes.golem]; }
    else if (stage === 5) { count = 1; pool = [enemyTypes.kurorekishi]; }
    else if (stage <= 9) { count = 3; pool = [enemyTypes.slime, enemyTypes.golem]; }
    else { count = 1; pool = [enemyTypes.nouki]; }

    let result = [];
    for(let i=0; i<count; i++) {
        let et = pool[Math.floor(Math.random()*pool.length)];
        result.push({ ...et, currentHp: et.hp, status: [] });
    }
    return result;
}

function refreshShop(){
    stageText.innerText="Stage "+stage; 
    coinText.innerText=coin; 
    shop=[];
    
    // æ¬¡ã®æ•µã‚’æ±ºå®šã—ã¦è¡¨ç¤º
    nextEnemies = generateNextEnemies();
    const enemyNames = nextEnemies.map(e => `${e.name}(${e.elem})`).join(", ");
    nextEnemyInfo.innerText = `æ¬¡: ${enemyNames}`;

    let pool= (stage<=3) ? [3] : (stage<=6) ? [3,4] : [3,3,4,4,5];
    for(let i=0;i<6;i++){
        let r=pool[Math.random()*pool.length|0];
        let list=baseChars.filter(c=>c.rarity==r);
        shop.push(copyChar(list[Math.random()*list.length|0]));
    }
    drawShop(); drawDeck();
}

function drawShop(){
    shopCards.innerHTML="";
    shop.forEach((c,i)=>{
        let d=document.createElement("div");
        d.className=`card rarity-${c.rarity}`;
        d.draggable=true;
        d.innerHTML=createCardHtml(c);
        d.ondragstart=e=>e.dataTransfer.setData("shopIndex",i);
        shopCards.appendChild(d);
    });
}

function drawDeck(){
    deckDiv.innerHTML="";
    deck.forEach((c,i)=>{
        let d=document.createElement("div");
        d.className=`card rarity-${c.rarity}`;
        d.draggable=true;
        d.innerHTML=createCardHtml(c);
        d.ondragstart=e=>e.dataTransfer.setData("deckIndex",i);
        deckDiv.appendChild(d);
    });
}

deckDiv.ondragover=e=>e.preventDefault();
deckDiv.ondrop=e=>{
    let i=e.dataTransfer.getData("shopIndex");
    if(i!=="") buy(Number(i));
};
sellZone.ondragover=e=>e.preventDefault();
sellZone.ondrop=e=>{
    let i=e.dataTransfer.getData("deckIndex");
    if(i!=="") { let c=deck[i]; coin+=cost(c.rarity); deck.splice(i,1); coinText.innerText=coin; drawDeck(); }
};

function buy(i){
    let c = shop[i], p = cost(c.rarity), sameChar = deck.find(dc => dc.name === c.name);
    if(coin < p) return;
    if(sameChar) {
        if(sameChar.rank < 5) { coin -= p; sameChar.rank += 1; shop.splice(i,1); }
        else { alert("æœ€å¤§ãƒ©ãƒ³ã‚¯ã§ã™ï¼"); return; }
    } else {
        if(deck.length >= 5) { alert("ãƒ‡ãƒƒã‚­ãŒã„ã£ã±ã„ã§ã™ï¼"); return; }
        coin -= p; deck.push(copyChar(c)); shop.splice(i,1);
    }
    coinText.innerText = coin; drawShop(); drawDeck();
}

function reroll(){ if(coin>0) { coin--; refreshShop(); } }

function battle(){ if(deck.length>0) { hideAllScreens(); battleDiv.classList.remove("hidden"); startBattle(); } }

function startBattle(){
    logDiv.innerHTML = "";
    // refreshShopã§æ±ºã‚ã¦ãŠã„ãŸæ•µã‚’ã‚»ãƒƒãƒˆ
    enemies = JSON.parse(JSON.stringify(nextEnemies));

    deck.forEach(c => { 
        c.currentHp = c.hp + (c.rank - 1) * 800; 
        c.status = []; 
    });

    battlePhase = "ally"; actorIndex = 0; drawEnemy(); drawAllies();
    log(`Stage ${stage}: ${enemies.length}ä½“ã®æ•µãŒç¾ã‚ŒãŸï¼`);
}

function nextTurn(){
    if (battlePhase === "end") finishBattle();
    else if (battlePhase === "ally") processAllyAction();
    else if (battlePhase === "enemy") processEnemyAction();
}

function processAllyAction() {
    if (actorIndex >= deck.length) { 
        deck.forEach(c => applyStatus(c)); 
        battlePhase = "enemy"; 
        actorIndex = 0;
        drawAllies(); nextTurn(); return; 
    }
    let actor = deck[actorIndex];
    if (actor.currentHp <= 0) { actorIndex++; processAllyAction(); return; }

    log(`--- ${actor.name} ã®è¡Œå‹• ---`);
    if (isStunned(actor)) {
        log(actor.name + " ã¯æ‹˜æŸã§å‹•ã‘ãªã„ï¼");
    } else {
        let aliveEnemies = enemies.filter(e => e.currentHp > 0);
        if (aliveEnemies.length > 0) {
            let target = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            
            if (actor.skill) {
                actor.skillCount++;
                if (actor.skillCount >= actor.skill.interval) {
                    log(`<b style='color:#ffff00;'>${actor.name} ãŒã‚¹ã‚­ãƒ«ã‚’ç™ºå‹•ã—ãŸï¼</b>`);
                    actor.skill.action(actor, aliveEnemies);
                    actor.skillCount = 0;
                }
            }
            dealDamage(actor, target, calcAtk(actor));
        }
    }
    actorIndex++; checkBattleEnd();
}

function processEnemyAction() {
    let aliveEnemies = enemies.filter(e => e.currentHp > 0);
    if (actorIndex >= aliveEnemies.length) {
        aliveEnemies.forEach(e => applyStatus(e));
        battlePhase = "ally"; actorIndex = 0; drawEnemy(); drawAllies();
        checkBattleEnd(); return;
    }

    let enemyActor = aliveEnemies[actorIndex];
    log(`--- ${enemyActor.name} ã®è¡Œå‹• ---`);
    let aliveAllies = deck.filter(c => c.currentHp > 0);
    
    if (aliveAllies.length > 0) {
        let atk = calcAtk(enemyActor);
        switch (enemyActor.action) {
            case "slime_skill":
                let t1 = aliveAllies[Math.floor(Math.random() * aliveAllies.length)];
                dealDamage(enemyActor, t1, atk); addStatus(t1, "æ¯’", 1, 2); addStatus(t1, "éº»ç—º", 1, 2); break;
            case "golem_skill":
                shuffleArray([...aliveAllies]).slice(0, 3).forEach(t => dealDamage(enemyActor, t, atk));
                if (Math.random() < 0.5) addStatus(enemyActor, "èˆˆå¥®", 1, 2); break;
            case "kuro_skill":
                aliveAllies.forEach(t => dealDamage(enemyActor, t, atk));
                shuffleArray([...aliveAllies]).slice(0, 2).forEach(t => addStatus(t, "æ¯’", 3, 2)); break;
            case "nouki_skill":
                shuffleArray([...aliveAllies]).slice(0, 2).forEach(t => dealDamage(enemyActor, t, atk));
                if (Math.random() < 0.5) addStatus(aliveAllies[Math.floor(Math.random() * aliveAllies.length)], "æ‹˜æŸ", 1, 2); break;
            default:
                dealDamage(enemyActor, aliveAllies[Math.floor(Math.random() * aliveAllies.length)], atk);
        }
    }
    actorIndex++;
    setTimeout(nextTurn, 400); 
}

function dealDamage(attacker, target, baseDmg) {
    const affinity = getAffinity(attacker.elem, target.elem);
    const finalDmg = Math.floor(baseDmg * affinity);
    
    target.currentHp = Math.max(0, target.currentHp - finalDmg);
    
    let logColor = affinity > 1.0 ? "#ffcc00" : (affinity < 1.0 ? "#aaaaaa" : "white");
    log(`${attacker.name}ã®æ”»æ’ƒï¼ ${target.name}ã« <span style="color:${logColor}">${finalDmg}</span> ãƒ€ãƒ¡ãƒ¼ã‚¸` + (affinity > 1.0 ? " (åŠ¹æœçµ¶å¤§ï¼)" : ""));
    
    let targetEl;
    if (enemies.includes(target)) {
        let aliveIndex = enemies.filter(e => e.currentHp > 0 || e === target).indexOf(target);
        targetEl = enemyArea.querySelectorAll('.card')[aliveIndex];
    } else {
        let aliveIndex = deck.filter(c => c.currentHp > 0 || c === target).indexOf(target);
        targetEl = allyArea.querySelectorAll('.card')[aliveIndex];
    }

    if (targetEl) { 
        targetEl.classList.add('dmg-flash'); 
        setTimeout(() => targetEl.classList.remove('dmg-flash'), 400); 
    }
    if (target.currentHp <= 0) log(`<b style='color:red;'>${target.name} ãŒæˆ¦é—˜ä¸èƒ½ï¼</b>`);
    drawEnemy(); drawAllies();
}

function addStatus(unit, type, level, turn) {
    if (!unit.status) unit.status = [];
    unit.status.push({ type, level, turn });
    log(`${unit.name} ã« ${type} ä»˜ä¸ï¼`);
    drawEnemy(); drawAllies();
}

function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }

function checkBattleEnd() {
    if (enemies.every(e => e.currentHp <= 0)) { 
        log("<b style='color:yellow;'>å‹åˆ©ï¼ ã‚¿ãƒƒãƒ—ã§æ¬¡ã¸</b>"); 
        battlePhase = "end"; 
    }
    else if (deck.every(c => c.currentHp <= 0)) { 
        log("<b style='color:red;'>æ•—åŒ—...</b>"); 
        battlePhase = "end"; 
    }
}

function finishBattle() {
    if (enemies.every(e => e.currentHp <= 0)) {
        coin += 5;
        stage++;
        deck.forEach(c => {
            const maxHp = c.hp + (c.rank - 1) * 800;
            c.currentHp = maxHp;
            c.status = [];
        });

        if (stage > 10) {
            hideAllScreens();
            clearScreen.classList.remove("hidden");
        } else {
            hideAllScreens();
            shopDiv.classList.remove("hidden");
            drawDeck(); 
            refreshShop();
        }
    } else {
        hideAllScreens();
        gameOverScreen.classList.remove("hidden");
    }
}

function calcAtk(unit){
    let baseAtk = unit.atk + (unit.rank ? (unit.rank - 1) * 80 : 0);
    let mult = 1.0;
    if(unit.status) unit.status.forEach(s=>{ if(s.type === "éº»ç—º") mult -= 0.3; if(s.type === "èˆˆå¥®") mult += 0.5; });
    return Math.floor(baseAtk * Math.max(0.1, mult));
}

function drawEnemy(){
    enemyArea.innerHTML = "";
    enemies.forEach(e => {
        if(e.currentHp <= 0) return;
        let d = document.createElement("div");
        d.className = "card rarity-4";
        d.innerHTML = createCardHtml(e, true);
        enemyArea.appendChild(d);
    });
}

function drawAllies(){
    allyArea.innerHTML="";
    deck.forEach(c=>{ if(c.currentHp>0) {
        let d = document.createElement("div");
        d.className = `card rarity-${c.rarity}`;
        d.innerHTML = createCardHtml(c);
        allyArea.appendChild(d);
    }});
}

function isStunned(c){ return c.status && c.status.some(s=>s.type==="æ‹˜æŸ"); }

function applyStatus(unit){
    if(!unit || !unit.status) return;
    unit.status.forEach((s,i)=>{ if(s.type==="æ¯’"){ unit.currentHp = Math.max(0, unit.currentHp - s.level*100); log(unit.name+" ã¯æ¯’ã§ "+(s.level*100)+"ãƒ€ãƒ¡"); } s.turn--; });
    unit.status = unit.status.filter(s => s.turn > 0);
}
</script>
</body>
</html>
