<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Card Rogue - Element Edition</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="fade"></div>
<h2 id="stageText">Stage 1</h2>

<div id="start">
    <h1>Card Rogue</h1>
    <button onclick="startGame()">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button>å›³é‘‘(æœªå®Ÿè£…)</button>
    <button onclick="alert('å±æ€§ã®å¼±ç‚¹ã‚’çªã„ã¦å‹åˆ©ã‚’ç›®æŒ‡ãã†ï¼')">ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«</button>
</div>

<div id="shop" class="hidden">
    <div style="display: flex; justify-content: space-around; align-items: center; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px; margin: 10px;">
        <div>Coin: <span id="coinText"></span></div>
        <div id="nextEnemyInfo" style="font-weight: bold; color: #ffcc00;">Next: ???</div>
    </div>
    
    <div id="shopCards"></div>
    <button onclick="reroll()">æ›´æ–°(1ã‚³ã‚¤ãƒ³)</button>
    <h3>ãƒ‡ãƒƒã‚­ (æœ€å¤§5æš / åŒã˜ã‚­ãƒ£ãƒ©ã§ãƒ©ãƒ³ã‚¯UP)</h3>
    <div id="deck"></div>
    <h3 style="color: #ff4444;">å£²å´ã‚¾ãƒ¼ãƒ³ (ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°)</h3>
    <div id="sellZone"></div>
    <button onclick="battle()" class="btn-battle">æˆ¦é—˜é–‹å§‹</button>
</div>

<div id="battle" class="hidden">
    <div id="log"></div>
    <div id="enemyArea"></div>
    <div id="allyArea" onclick="nextTurn()"></div>
</div>

<div id="clearScreen" class="hidden">
    <h1>GAME CLEAR</h1>
    <button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<div id="gameOverScreen" class="hidden">
    <h1 class="text-danger">GAME OVER</h1>
    <button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<script>
// --- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ ---
const baseChars = [
    { name: "å–œãƒ¶æ¥½ ã‚¹ã‚¦", rarity: 3, elem: "å…‰", atk: 300, hp: 3000, 
      skill: { timing: "attack", interval: 3, action: (a, ts, ds) => {
          ts.forEach(t => addStatus(t, "éº»ç—º", 1, 2));
          log("ç›¸æ‰‹ãƒãƒ¼ãƒ ã«éº»ç—ºã‚’ä»˜ä¸ï¼");
      }}},
    { name: "ãƒ•ãƒ¥ãƒ¼ãƒ ï½¥ã‚«ã‚¿ãƒ©ã‚°ãƒ¼ãƒ³", rarity: 5, elem: "é—‡", atk: 500, hp: 5500, 
      skill: { timing: "start", action: (a, ts, ds) => {
          addStatus(a, "èˆˆå¥®", 3, 3);
          ts.forEach(t => addStatus(t, "æ‹˜æŸ", 1, 1));
          log("æ•µå…¨å“¡ã‚’æ‹˜æŸã—ãŸï¼");
      }}},
    { name: "ãƒ¬ã‚ªãƒŠï½¥ãƒ•ã‚£ãƒœãƒŠãƒƒãƒ", rarity: 4, elem: "è‰", atk: 400, hp: 5000, 
      skill: { timing: "attack", interval: 3, action: (a, ts, ds) => {
          ds.forEach(d => {
              const maxHp = d.hp + (d.rank - 1) * 800;
              d.currentHp = Math.min(maxHp, d.currentHp + 1000);
          });
          log("å‘³æ–¹å…¨å“¡ã®ä½“åŠ›ã‚’å›å¾©ï¼");
      }}},
    { name: "è‘›é£¾ ã‚³ã‚¦", rarity: 5, elem: "ç«", atk: 700, hp: 5000, 
      skill: { timing: "attack", interval: 2, action: (a, ts, ds) => {
          if (Math.random() < 0.75) {
              addStatus(a, "èˆˆå¥®", 3, 3);
              log("è‘›é£¾ ã‚³ã‚¦ã€èˆˆå¥®çŠ¶æ…‹ï¼");
          }
      }}},
    { name: "å½¹æ¡ ã‚­ãƒ§ã‚¦", rarity: 3, elem: "é—‡", atk: 200, hp: 2000, 
      skill: { timing: "attack", interval: 2, action: (a, ts, ds) => {
          let target = ts[Math.floor(Math.random() * ts.length)];
          addStatus(target, "éº»ç—º", 1, 2);
          log(`${target.name}ã‚’ç—ºã‚Œã•ã›ãŸï¼`);
      }}},
    { name: "ãƒªã‚²ãƒ«", rarity: 3, elem: "æ°´", atk: 300, hp: 3000, 
      skill: { timing: "start", action: (a, ts, ds) => {
          let target = ds[Math.floor(Math.random() * ds.length)];
          if(target) target.currentHp = Math.max(1, target.currentHp - 500);
          ds.forEach(d => addStatus(d, "èˆˆå¥®", 2, 2));
          log("ãƒªã‚²ãƒ«ã®é–‹å¹•æ”¯æ´ï¼");
      }}},
    { name: "åŠ è¥¿ ã‚«ãƒ•", rarity: 4, elem: "æ°´", atk: 400, hp: 5000, 
      skill: { timing: "attack", interval: 3, action: (a, ts, ds) => {
          let target = ts[Math.floor(Math.random() * ts.length)];
          addStatus(target, "æ‹˜æŸ", 1, 2);
          log(`${target.name}ã‚’æ‹˜æŸï¼`);
      }}},
    { name: "ã‚¤ã‚°ãƒã‚¢ï½¥ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«", rarity: 3, elem: "å…‰", atk: 100, hp: 2000, 
      skill: { timing: "start", action: (a, ts, ds) => {
          ds.forEach(d => addStatus(d, "èˆˆå¥®", 2, 5));
          log("æˆ¦æ„ãŒé«˜æšã—ã¦ã„ã‚‹ï¼");
      }}},
    { name: "ãƒªãƒ¼ãƒ´ï½¥ã‚¢ãƒ¬ã‚¯ã‚µãƒ³ãƒ€ãƒ¼", rarity: 5, elem: "ç«", atk: 999, hp: 9999 }
];

// --- æ•µãƒ‡ãƒ¼ã‚¿ï¼ˆå¼·åŒ–ç‰ˆï¼‰ ---
const enemyTypes = {
    slime: { 
        name: "ã‚¹ãƒ©ã‚¤ãƒ ", hp: 3500, atk: 700, elem: "æ°´", 
        skill: { name: "å¢—æ®–", interval: 2, action: (e) => {
            e.currentHp = Math.min(e.hp, e.currentHp + 800);
            log("ã‚¹ãƒ©ã‚¤ãƒ ã¯å¢—æ®–ã—ã¦å›å¾©ã—ãŸï¼");
        }}
    },
    golem: { 
        name: "ã‚´ãƒ¼ãƒ¬ãƒ ", hp: 6000, atk: 400, elem: "è‰",
        skill: { name: "ç¡¬åŒ–", interval: 3, action: (e) => {
            addStatus(e, "èˆˆå¥®", 1, 2); // æ”»æ’ƒã‚¢ãƒƒãƒ—
            log("ã‚´ãƒ¼ãƒ¬ãƒ ã®ä½“ãŒç¡¬è³ªåŒ–ã—ãŸï¼");
        }}
    },
    kurorekishi: { name: "é»’æ­´å²", hp: 8000, atk: 200, elem: "é—‡" },
    nouki: { name: "ç´æœŸ", hp: 12000, atk: 800, elem: "é—‡" }
};

// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let stage=1, coin=6, deck=[], shop=[];
let enemies = [], nextEnemies = [];
let battleQueue = [];

const ui_start = document.getElementById("start");
const ui_shop = document.getElementById("shop");
const ui_battle = document.getElementById("battle");
const ui_clear = document.getElementById("clearScreen");
const ui_over = document.getElementById("gameOverScreen");
const shopCards=document.getElementById("shopCards"), deckDiv=document.getElementById("deck"), sellZone=document.getElementById("sellZone");
const coinText=document.getElementById("coinText"), stageText=document.getElementById("stageText"), nextEnemyInfo=document.getElementById("nextEnemyInfo");
const enemyArea=document.getElementById("enemyArea"), allyArea=document.getElementById("allyArea"), logDiv=document.getElementById("log");

// --- ç”»é¢åˆ‡ã‚Šæ›¿ãˆ ---
function hideAllScreens() {
    [ui_start, ui_shop, ui_battle, ui_clear, ui_over].forEach(div => { if(div) div.classList.add("hidden"); });
}

window.onload=()=>{ hideAllScreens(); ui_start.classList.remove("hidden"); };

function startGame(){ 
    stage=1; coin=6; deck=[]; 
    hideAllScreens(); ui_shop.classList.remove("hidden"); 
    refreshShop(); 
}

// --- ã‚·ã‚¹ãƒ†ãƒ é–¢æ•° ---
function log(t){ 
    logDiv.innerHTML += `<div>${t}</div>`; 
    logDiv.scrollTop = logDiv.scrollHeight; 
}
function cost(r){return r==3?2:r==4?3:4;}
function copyChar(c){return {...c,rank:1,currentHp:c.hp,status:[],skillCount:0};}
function getIcon(type){
    switch(type){
        case "æ¯’": return "â˜ ï¸"; case "éº»ç—º": return "âš¡";
        case "æ‹˜æŸ": return "â›“ï¸"; case "èˆˆå¥®": return "ğŸ’¥";
        default: return "â“";
    }
}

function getAffinity(aElem, tElem) {
    const table = { "ç«": "è‰", "è‰": "æ°´", "æ°´": "ç«", "å…‰": "é—‡", "é—‡": "å…‰" };
    if (table[aElem] === tElem) return 1.5;
    if (table[tElem] === aElem) return 0.5;
    return 1.0;
}

function createCardHtml(c, isEnemy = false) {
    const stars = "â˜…".repeat(c.rarity || 3);
    const maxHp = isEnemy ? c.hp : (c.hp + (c.rank - 1) * 800);
    const currentHp = Math.ceil(c.currentHp !== undefined ? c.currentHp : maxHp);
    const atk = calcAtk(c);
    const skillInfo = (c.skill && c.skill.interval) ? `<div class="skill-tag">${c.skillCount || 0}/${c.skill.interval}</div>` : "";
    const statusIcons = (c.status || []).map(s => `<span>${getIcon(s.type)}${s.turn}</span>`).join("");
    const imgPath = `img/${c.name}.png`;

    return `
        ${skillInfo}
        <div class="elem-circle elem-${c.elem}">${isEnemy ? "" : (c.rank || 1)}</div>
        <div class="rarity-stars">${stars}</div>
        <div class="card-status-icons">${statusIcons}</div>
        <div class="card-img-space">
            <img src="${imgPath}" onerror="this.style.visibility='hidden'">
        </div>
        <div class="card-name">${c.name}</div>
        <div class="card-atk">âš”ï¸${atk}</div>
        <div class="card-hp">â™¥${currentHp}</div>
    `;
}

function backToTitle(){
    stage = 1; coin = 6; hideAllScreens(); ui_start.classList.remove("hidden");
    logDiv.innerHTML=""; coinText.innerText = coin; stageText.innerText = "Stage 1";
    deck = []; drawDeck();
}

function generateNextEnemies() {
    let pool = [enemyTypes.slime, enemyTypes.golem];
    let count = Math.min(4, Math.floor(stage / 2) + 1);
    let result = [];
    if(stage===5) result.push({...enemyTypes.kurorekishi, currentHp: enemyTypes.kurorekishi.hp, status: [], skillCount: 0});
    if(stage===10) result.push({...enemyTypes.nouki, currentHp: enemyTypes.nouki.hp, status: [], skillCount: 0});
    while(result.length < count) {
        let et = pool[Math.floor(Math.random()*pool.length)];
        result.push({ ...et, currentHp: et.hp, status: [], skillCount: 0 });
    }
    return result;
}

function refreshShop(){
    stageText.innerText="Stage "+stage; coinText.innerText=coin; shop=[];
    nextEnemies = generateNextEnemies();
    nextEnemyInfo.innerText = `æ¬¡: ${nextEnemies.map(e=>e.name).join(", ")}`;
    let pool= (stage<=3) ? [3] : (stage<=6) ? [3,4] : [3,4,5];
    for(let i=0;i<6;i++){
        let r=pool[Math.floor(Math.random()*pool.length)];
        let list=baseChars.filter(c=>c.rarity==r);
        shop.push(copyChar(list[Math.floor(Math.random()*list.length)]));
    }
    drawShop(); drawDeck();
}

function drawShop(){
    shopCards.innerHTML="";
    shop.forEach((c,i)=>{
        let d=document.createElement("div");
        d.className=`card rarity-${c.rarity}`;
        d.draggable=true; d.innerHTML=createCardHtml(c);
        d.ondragstart=e=>e.dataTransfer.setData("shopIndex",i);
        shopCards.appendChild(d);
    });
}

function drawDeck(){
    deckDiv.innerHTML="";
    deck.forEach((c,i)=>{
        let d=document.createElement("div");
        d.className=`card rarity-${c.rarity}`;
        d.draggable=true; d.innerHTML=createCardHtml(c);
        d.ondragstart=e=>e.dataTransfer.setData("deckIndex",i);
        deckDiv.appendChild(d);
    });
}

deckDiv.ondragover=e=>e.preventDefault();
deckDiv.ondrop=e=>{
    let i=e.dataTransfer.getData("shopIndex");
    if(i!=="") buy(Number(i));
};
sellZone.ondragover=e=>e.preventDefault();
sellZone.ondrop=e=>{
    let i=e.dataTransfer.getData("deckIndex");
    if(i!=="") { let c=deck[i]; coin+=cost(c.rarity); deck.splice(i,1); coinText.innerText=coin; drawDeck(); }
};

function buy(i){
    let c = shop[i], p = cost(c.rarity), sameChar = deck.find(dc => dc.name === c.name);
    if(coin < p) return;
    if(sameChar) { if(sameChar.rank < 5) { coin -= p; sameChar.rank += 1; shop.splice(i,1); } }
    else { if(deck.length >= 5) return; coin -= p; deck.push(copyChar(c)); shop.splice(i,1); }
    coinText.innerText = coin; drawShop(); drawDeck();
}

function reroll(){ if(coin>0) { coin--; refreshShop(); } }

function battle(){ 
    if(deck.length>0) { 
        hideAllScreens(); 
        ui_battle.classList.remove("hidden"); 
        startBattle(); 
    } 
}

function startBattle(){
    logDiv.innerHTML = "<b>--- æˆ¦é—˜é–‹å§‹ ---</b><br>";
    battleQueue = [];
    enemies = JSON.parse(JSON.stringify(nextEnemies));
    deck.forEach(c => { 
        c.currentHp = c.hp + (c.rank - 1) * 800; 
        c.status = []; 
        c.skillCount = 0; 
    });

    deck.forEach(c => {
        if(c.skill && c.skill.timing === "start") {
            battleQueue.push({ type: "skill", actor: c });
        }
    });

    prepareTurn();
    drawEnemy(); drawAllies();
}

function prepareTurn() {
    let aliveAllies = deck.filter(c => c.currentHp > 0);
    let aliveEnemies = enemies.filter(e => e.currentHp > 0);
    if (aliveEnemies.length === 0 || aliveAllies.length === 0) return;

    aliveAllies.forEach(c => battleQueue.push({ type: "action", actor: c, side: "ally" }));
    aliveEnemies.forEach(e => battleQueue.push({ type: "action", actor: e, side: "enemy" }));
}

function nextTurn(){
    if (battleQueue.length === 0) {
        if (enemies.every(e => e.currentHp <= 0) || deck.every(c => c.currentHp <= 0)) {
            finishBattle();
        } else {
            // ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã®çŠ¶æ…‹ç•°å¸¸æ›´æ–°
            [...deck, ...enemies].forEach(u => applyStatus(u));
            prepareTurn();
            if(battleQueue.length > 0) nextTurn();
        }
        return;
    }

    let task = battleQueue.shift();
    let actor = task.actor;
    if (actor.currentHp <= 0) { nextTurn(); return; }

    if (task.type === "skill") {
        log(`<b style='color:#00ffff;'>${actor.name}ã®ã‚¹ã‚­ãƒ«ï¼</b>`);
        actor.skill.action(actor, enemies, deck);
        drawEnemy(); drawAllies();
    } 
    else if (task.type === "action") {
        if (isStunned(actor)) {
            log(`${actor.name}ã¯æ‹˜æŸã•ã‚Œã¦ã„ã‚‹ï¼`);
            nextTurn(); return;
        }

        // æ•µã®ã‚¹ã‚­ãƒ«åˆ¤å®š
        if (task.side === "enemy" && actor.skill) {
            actor.skillCount++;
            if (actor.skillCount >= actor.skill.interval) {
                actor.skill.action(actor);
                actor.skillCount = 0;
                drawEnemy(); drawAllies();
            }
        }

        let targets = (task.side === "ally") ? enemies.filter(e => e.currentHp > 0) : deck.filter(c => c.currentHp > 0);
        if (targets.length === 0) { nextTurn(); return; }

        let target = targets[Math.floor(Math.random() * targets.length)];

        // å‘³æ–¹ã®ã‚¹ã‚­ãƒ«åˆ¤å®š
        if (task.side === "ally" && actor.skill && actor.skill.timing === "attack") {
            actor.skillCount++;
            if (actor.skillCount >= actor.skill.interval) {
                log(`<b style='color:#ffff00;'>${actor.name}ã®ã‚¹ã‚­ãƒ«ç™ºå‹•ï¼</b>`);
                actor.skill.action(actor, targets, deck);
                actor.skillCount = 0;
            }
        }

        log(`${actor.name}ã®æ”»æ’ƒï¼`);
        dealDamage(actor, target, calcAtk(actor));
    }
}

function dealDamage(attacker, target, baseDmg) {
    const affinity = getAffinity(attacker.elem, target.elem);
    const finalDmg = Math.floor(baseDmg * affinity);
    target.currentHp = Math.max(0, target.currentHp - finalDmg);

    let color = affinity > 1 ? "#ff4444" : affinity < 1 ? "#aaa" : "#fff";
    log(`<span style="color:${color}">${target.name}ã« ${finalDmg} âš¡</span>`);

    let targetEl;
    if (enemies.includes(target)) {
        let aliveIndex = enemies.filter(e => e.currentHp > 0 || e === target).indexOf(target);
        targetEl = enemyArea.querySelectorAll('.card')[aliveIndex];
    } else {
        let aliveIndex = deck.filter(c => c.currentHp > 0 || c === target).indexOf(target);
        targetEl = allyArea.querySelectorAll('.card')[aliveIndex];
    }

    if (targetEl) {
        targetEl.classList.add('dmg-flash');
        const popup = document.createElement("div");
        popup.className = "dmg-popup"; popup.innerText = finalDmg;
        targetEl.appendChild(popup);
        setTimeout(() => { 
            targetEl.classList.remove('dmg-flash'); 
            popup.remove(); 
            drawEnemy(); drawAllies(); 
            if(target.currentHp <= 0) log(`<b>${target.name}ã‚’æ’ƒç ´ï¼</b>`);
        }, 400);
    }
}

function addStatus(unit, type, level, turn) { 
    if (!unit.status) unit.status = []; 
    unit.status.push({ type, level, turn }); 
}

function finishBattle() {
    if (enemies.every(e => e.currentHp <= 0)) {
        coin += 5; stage++;
        if (stage > 10) { hideAllScreens(); ui_clear.classList.remove("hidden"); }
        else { hideAllScreens(); ui_shop.classList.remove("hidden"); refreshShop(); }
    } else { hideAllScreens(); ui_over.classList.remove("hidden"); }
}

function calcAtk(unit){
    let baseAtk = unit.atk + (unit.rank ? (unit.rank - 1) * 80 : 0);
    let mult = 1.0;
    if(unit.status) unit.status.forEach(s=>{ if(s.type === "éº»ç—º") mult -= 0.3; if(s.type === "èˆˆå¥®") mult += 0.5; });
    return Math.floor(baseAtk * Math.max(0.1, mult));
}

function drawEnemy(){
    enemyArea.innerHTML = "";
    enemies.forEach(e => { if(e.currentHp > 0) {
        let d = document.createElement("div"); d.className = "card rarity-4";
        d.innerHTML = createCardHtml(e, true); enemyArea.appendChild(d);
    }});
}

function drawAllies(){
    allyArea.innerHTML="";
    deck.forEach(c=>{ if(c.currentHp>0) {
        let d = document.createElement("div"); d.className = `card rarity-${c.rarity}`;
        d.innerHTML = createCardHtml(c); allyArea.appendChild(d);
    }});
}

function isStunned(c){ return c.status && c.status.some(s=>s.type==="æ‹˜æŸ"); }
function applyStatus(unit){
    if(!unit || !unit.status) return;
    unit.status.forEach(s=>{ if(s.type==="æ¯’") unit.currentHp = Math.max(0, unit.currentHp - 100); s.turn--; });
    unit.status = unit.status.filter(s => s.turn > 0);
}
</script>
</body>
</html>
